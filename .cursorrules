# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again. 

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Tools

Note all the tools are in typescript. So in the case you need to do batch processing, you can always consult the typescript files and write your own script.

## Screenshot Verification

The screenshot verification workflow allows you to capture screenshots of web pages and verify their appearance using LLMs. The following tools are available:

1. Screenshot Capture:
```bash
npx tsx src/tools/screenshot_utils.ts URL [--output OUTPUT] [--width WIDTH] [--height HEIGHT]
```

2. LLM Verification with Images:
```bash
npx tsx src/tools/llm_api.ts --prompt "Your verification question" --provider {openai|anthropic} --image path/to/screenshot.png
```

Example workflow:
```typescript
import { takeScreenshot } from '../src/tools/screenshot_utils';
import { queryLlm } from '../src/tools/llm_api';

// Take a screenshot
async function verifyWebpage() {
  const screenshotPath = await takeScreenshot('https://example.com', 'screenshot.png');

  // Verify with LLM
  const response = await queryLlm(
    "What is the background color and title of this webpage?",
    null,
    null,
    "openai",  // or "anthropic"
    screenshotPath
  );
  console.log(response);
}

verifyWebpage().catch(console.error);
```

## LLM

You always have an LLM at your side to help you with the task. For simple tasks, you could invoke the LLM by running the following command:
```
npx tsx src/tools/llm_api.ts --prompt "What is the capital of France?" --provider "anthropic"
```

The LLM API supports multiple providers:
- OpenAI (default, model: gpt-4o)
- Azure OpenAI (model: configured via AZURE_OPENAI_MODEL_DEPLOYMENT in .env file, defaults to gpt-4o-ms)
- DeepSeek (model: deepseek-chat)
- Anthropic (model: claude-3-sonnet-20240229)
- Gemini (model: gemini-pro)
- Local LLM (model: Qwen/Qwen2.5-32B-Instruct-AWQ)

But usually it's a better idea to check the content of the file and use the APIs in the `src/tools/llm_api.ts` file to invoke the LLM if needed:

```typescript
import { queryLlm } from '../src/tools/llm_api';

async function askLlm() {
  const response = await queryLlm(
    "What is the capital of France?",
    null,
    null,
    "anthropic"
  );
  console.log(response);
}

askLlm().catch(console.error);
```

## Web browser

You could use the `src/tools/web_scraper.ts` file to scrape the web.
```
npx tsx src/tools/web_scraper.ts --max-concurrent 3 URL1 URL2 URL3
```
This will output the content of the web pages.

You can also use the API programmatically:

```typescript
import { processUrls } from '../src/tools/web_scraper';

async function scrapeWebsites() {
  const urls = ['https://example.com', 'https://example.org'];
  const contents = await processUrls(urls, 3); // 3 is maxConcurrent
  contents.forEach((content, index) => {
    console.log(`Content from ${urls[index]}:`);
    console.log(content);
  });
}

scrapeWebsites().catch(console.error);
```

## Search engine

You could use the `src/tools/search_engine.ts` file to search the web.
```
npx tsx src/tools/search_engine.ts "your search keywords"
```
This will output the search results in the following format:
```
URL: https://example.com
Title: This is the title of the search result
Snippet: This is a snippet of the search result
```

You can also use the API programmatically:

```typescript
import { searchWithRetry, formatResults } from '../src/tools/search_engine';

async function searchWeb() {
  const results = await searchWithRetry("your search keywords", 10, 3);
  formatResults(results);
}

searchWeb().catch(console.error);
```

If needed, you can further use the `web_scraper.ts` file to scrape the web page content.

# Lessons

## User Specified Lessons

- Use pnpm to install dependencies.
- LLM provider can be changed using --provider parameter in command line, default is 'deepseek'. Each provider has its own default model and requires corresponding API key in environment variables.
- Include info useful for debugging in the program output.
- Read the file before you try to edit it.
- Due to Cursor's limit, when you use `git` and `gh` and need to submit a multiline commit message, first write the message in a file, and then use `git commit -F <filename>` or similar command to commit. And then remove the file. Include "[Cursor] " in the commit message and PR title.

## Cursor learned

- For search results, ensure proper handling of different character encodings (UTF-8) for international queries
- Add debug information to stderr while keeping the main output clean in stdout for better pipeline integration
- When using seaborn styles in matplotlib, use 'seaborn-v0_8' instead of 'seaborn' as the style name due to recent seaborn version changes
- Use 'gpt-4o' as the model name for OpenAI's GPT-4 with vision capabilities
- When searching for recent news, use the current year (2025) instead of previous years, or simply use the "recent" keyword to get the latest information

# Scratchpad

## 将Python工具转换为TypeScript实现

任务：将当前的Python工具转换为TypeScript实现，包括工具和测试文件。

### 计划
[X] 分析当前项目结构和Python实现
[X] 创建TypeScript项目基础结构（package.json, tsconfig.json, jest.config.js）
[X] 将Python工具转换为TypeScript实现
  [X] llm_api.py -> llm_api.ts
  [X] screenshot_utils.py -> screenshot_utils.ts
  [X] search_engine.py -> search_engine.ts
  [X] web_scraper.py -> web_scraper.ts
[X] 创建入口点index.ts
[X] 创建测试文件
  [X] llm_api.test.ts
  [X] screenshot_utils.test.ts
  [X] search_engine.test.ts
  [X] web_scraper.test.ts
[X] 修复类型错误和构建问题
[X] 运行测试并总结

### 完成情况

我们已经成功地将Python工具转换为TypeScript实现。主要完成了以下工作：

1. 创建了TypeScript项目的基本结构：
   - package.json：定义项目依赖和脚本
   - tsconfig.json：配置TypeScript编译选项
   - jest.config.js：配置Jest测试框架

2. 实现了四个主要工具：
   - llm_api.ts：与各种LLM提供商交互的API
   - screenshot_utils.ts：使用Playwright截取网页截图
   - search_engine.ts：使用DuckDuckGo搜索引擎进行网络搜索
   - web_scraper.ts：使用Playwright抓取网页内容

3. 创建了入口点index.ts，用于从命令行调用这些工具

4. 编写了测试文件，但它们需要进一步修复

5. 解决了一些类型错误和构建问题：
   - 修复了Google Generative AI库的API调用方式
   - 添加了类型定义文件
   - 修复了测试文件中的类型错误

项目现在可以成功构建，但测试仍然有一些失败，需要进一步修复。这些失败主要是由于测试模拟和异步操作的问题。

### 下一步

如果需要继续完善这个项目，可以考虑：

1. 修复测试文件中的问题
2. 添加更多的类型定义和接口
3. 改进错误处理和日志记录
4. 添加更多的文档和示例
5. 实现更多的功能和工具

## 将 cursor rules 里的 tools 更新为 ts 的调用

任务：将 .cursorrules 文件中的工具部分从 Python 示例更新为 TypeScript 示例。

### 计划
[X] 查看当前的 .cursorrules 文件内容
[X] 检查 TypeScript 版本的工具文件
[X] 更新 .cursorrules 文件中的工具部分
  [X] 更新命令行调用路径
  [X] 将 Python 示例代码转换为 TypeScript 示例代码
  [X] 添加更多的 TypeScript API 使用示例
